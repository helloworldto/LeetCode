# 202. 快乐数 #
思路：按照题目要求加法，需要注意的问题：无限循环该如何处理 
解决方法：写死，如果循环次数大于10 则直接返回false;(因为其实和不为1是因为陷入循环中，因此写死了) 执行结果较差 5.74%和8.33%

	class Solution {
	    public boolean isHappy(int n) {
	       boolean flag = false;
	       int index = 0;
	       while(!flag){
	           index++;
	           String str = n +"";
	           int num = 0;
	           for(int i = 0; i < str.length();i++){
	               int da= Integer.valueOf(str.substring(i,i+1));
	                num += da*da;
	                
	           }
	           if(num == 1) flag = true;
	           if(index > 10) return false;
	           n = num;
	       }
	       if(flag) return true;
	       return false; 
	    }
	}

# 203. 移除链表元素 #
思路：三个指针，第一个是root，令root.next = head确保head的val等于val时链表不会丢失，第二个pre是删除链表时的前驱，第三个tmp是当前要删除的结点

	class Solution {
	    public ListNode removeElements(ListNode head, int val) {
	        if(head == null) return head;
	        ListNode root = new ListNode();//防止head就是要删除的结点
	        ListNode pre = root;
	        root.next = head;
	        ListNode tmp = head;
	    
	        while(tmp != null){
	            if(tmp.val == val) pre.next = tmp.next;
	            else pre = pre.next;
	            tmp = tmp.next;   
	        }
	        return root.next;
	    }
	}

# 204. 计数质数 #
从2开始计算 问题：超出时间范围

	class Solution {
	    public int countPrimes(int n) {
	        int count = 0;
	        if(n < 2) return 0;
	
	        for(int i = 2; i < n;i++){
	            int len = i/2;
	            boolean flag = false;
	            for(int j = 2; j <= len;j++){
	                if( i % j == 0) {flag = true;break;}
	
	            }
	            if(!flag) count++;
	        }
	        return count;
	    }
	}

改进

	class Solution {
	    public int countPrimes(int n) {
	       int result = 0;
	       boolean[] b = new boolean[n];
	       if(n > 2) result++;
	       for(int i = 3; i < n; i+=2){
	           if(!b[i]){
	               for(int j = 3; i *j < n;j+=2){
	                   b[i*j] = true;
	               }
	               result++;
	           }
	       }
	       return result;
	    }
	}

# 205. 同构字符串 #

	class Solution {
	    public boolean isIsomorphic(String s, String t) {
	         int length = s.length();
	        char[] sarray = s.toCharArray();
	        char[] tarray = t.toCharArray();
	        Map map = new HashMap();
	        
	        for(int i=0; i<length; i++)
	        {
	            if(map.get(sarray[i]) != null){
	                sarray[i] =(char) map.get(sarray[i]);
	            }else{
	                if(map.containsValue(tarray[i])){ //判断是否多键对应一个值
	                    return false;
	                }
	                map.put(sarray[i],tarray[i]);      
	                sarray[i] = tarray[i];
	            }
	            
	            if(sarray[i] != tarray[i])
	            {
	                return false;
	            }
	        }
	        
	        return true;
	
	
	
	    }
	}