# 557. 反转字符串中的单词 III #
思路：使用栈存储字符，如果不是空，则入栈，如果是空，则将栈内元素依次弹出

	class Solution {
	    public String reverseWords(String s) {
	       StringBuilder sb = new StringBuilder();
	       Stack<Character> stack = new Stack<>();
	
	       for(char c : s.toCharArray()){
	           if(c != ' ')
	                stack.push(c);
	            else{
	                while(!stack.isEmpty())
	                    sb.append(stack.pop());
	                sb.append(' ');
	            }
	            
	       }
	       while(!stack.isEmpty())
	            sb.append(stack.pop());
	       return sb.toString();
	
	    }
	}

# 54. 螺旋矩阵 #
思路：按照题目要求，顺时针方向，依次求解 问题 超出时间限制

	class Solution {
	    public List<Integer> spiralOrder(int[][] matrix) {
	        int left=0,top = 0;
	        int right = matrix[0].length-1, bottom = matrix.length-1;
	        int index1=0,index2 = 0;
	        List<Integer> list = new ArrayList<Integer>();
	        while(left != right &&  top != bottom){
	            
	            while(left <= right)
	                list.add(matrix[top][left++]);
	            index1++;
	            left--;
	            while(top < bottom)
	                list.add(matrix[++top][right]);
	            
	            index2++;
	            
	            
	            while(left >= index1)
	                list.add(matrix[bottom][--left]);
	            while(top >= index2)
	                list.add(matrix[--top][left]);
	            bottom--;
	            right--;        
	        }
	
	        return list;
	    }
	}


改进

	class Solution {
	    public List<Integer> spiralOrder(int[][] matrix) {
	        List ans = new ArrayList();
	        if (matrix.length == 0) return ans;
	        int R = matrix.length, C = matrix[0].length;
	        boolean[][] seen = new boolean[R][C];
	        int[] dr = {0, 1, 0, -1};
	        int[] dc = {1, 0, -1, 0};
	        int r = 0, c = 0, di = 0;
	        for (int i = 0; i < R * C; i++) {
	            ans.add(matrix[r][c]);
	            seen[r][c] = true;
	            int cr = r + dr[di];
	            int cc = c + dc[di];
	            if (0 <= cr && cr < R && 0 <= cc && cc < C && !seen[cr][cc]){
	                r = cr;
	                c = cc;
	            } else {
	                di = (di + 1) % 4;
	                r += dr[di];
	                c += dc[di];
	            }
	        }
	        return ans;
	    }
	
	}