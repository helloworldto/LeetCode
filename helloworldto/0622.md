# 169. 多数元素 #
思路：排序后统计个数

	class Solution {
	    public int majorityElement(int[] nums) {
	        int len = nums.length;
	        int num = 0;
	        Arrays.sort(nums);
	        for(int i = 1; i < len;i++){
	            if(nums[i] == nums[i-1]) num++;
	            else num = 1;
	            if(num > len/2) return nums[i];
	        }
	        return nums[0];
	    }
	}

思路：hashmap  然鹅更慢

	class Solution {
	    public int majorityElement(int[] nums) {
	        int len = nums.length;
	        HashMap<Integer,Integer> map = new HashMap<>();
	        for(int i = 0; i < len;i++){
	            if(!map.containsKey(nums[i])) map.put(nums[i],1);
	            else{
	                int num = map.get(nums[i]) + 1;
	                if(num > len/2) return nums[i];
	                else map.put(nums[i],num);
	
	            }
	        }
	
	        return nums[0];
	    }
	}


# 15. 三数之和 #
思路：排序，for循环 如果该元素已经大于0 则之间退出 否则的话再进行循环 

	class Solution {
	    public List<List<Integer>> threeSum(int[] nums) {
	        List<List<Integer>> list = new ArrayList();
	        if(nums == null || nums.length <3) return list;
	        Arrays.sort(nums);
	        for(int i = 0; i < nums.length;i++){
	            if(nums[i] > 0) break;//排序后如果一个数大于0，那么该数以后的都不可能
	            if(i > 0 && nums[i] == nums[i-1]) continue;//去重
	            int L = i + 1;
	            int R = nums.length -1;
	            while(L < R){
	                int sum = nums[i] + nums[L] + nums[R];
	                if(sum == 0){
	                    list.add(Arrays.asList(nums[i],nums[L],nums[R]));
	                    while(L < R && nums[L] == nums[L + 1]) L++;
	                    while(L < R && nums[R] == nums[R - 1]) R--;
	                    L++;
	                    R--;
	                }
	                else if(sum < 0 ) L++;
	                else if(sum > 0) R--;
	            }
	
	        }
	        return list;
	
	    }
	}

# 312. 戳气球 #
思路：动态规划，转换方程是 ans = Math.max(ans, nums[left] * nums[i] * nums[right] + dp(memo, nums, left, i) + dp(memo, nums, i, right));

	class Solution {
	    public int maxCoins(int[] nums) {
	
	        // reframe the problem
	        int n = nums.length + 2;
	        int[] new_nums = new int[n];
	
	        for(int i = 0; i < nums.length; i++){
	            new_nums[i+1] = nums[i];
	        }
	
	        new_nums[0] = new_nums[n - 1] = 1;
	
	        // cache the results of dp
	        int[][] memo = new int[n][n];
	
	        // find the maximum number of coins obtained from adding all balloons from (0, len(nums) - 1)
	        return dp(memo, new_nums, 0, n - 1);
	    }
	
	    public int dp(int[][] memo, int[] nums, int left, int right) {
	        // no more balloons can be added
	        if (left + 1 == right) return 0;
	
	        // we've already seen this, return from cache
	        if (memo[left][right] > 0) return memo[left][right];
	
	        // add each balloon on the interval and return the maximum score
	        int ans = 0;
	        for (int i = left + 1; i < right; ++i)
	            ans = Math.max(ans, nums[left] * nums[i] * nums[right]
	            + dp(memo, nums, left, i) + dp(memo, nums, i, right));
	        // add to the cache
	        memo[left][right] = ans;
	        return ans;
	    }
	}



