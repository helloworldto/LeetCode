# 面试题 17.24. 最大子矩阵 #
参考大佬思路：找每一行的连续子串，不断叠加并更新

	class Solution {
	    public int[] getMaxMatrix(int[][] matrix) {
	         int[] ans = new int[4]; //存储目前为止的最大子矩阵位置
	        int max_sum = matrix[0][0]; //存储目前为止最大子矩阵和的大小
	        for(int r1 = 0;r1 < matrix.length;r1++){//子矩阵的上边缘
	            int[] dp = new int[matrix[0].length];
	            for(int r2 = r1;r2 < matrix.length;r2++){//一维的前缀和问题
	                int dpsum = 0; //累加和
	                int min_dpsum = 0; //累加和最小值
	                int min_dpsum_index = -1; //累加和最小值对应坐标
	                for(int c2 = 0;c2 < matrix[0].length;c2++){ 
	                    dp[c2] += matrix[r2][c2];
	                    dpsum += dp[c2];
	                    if(dpsum-min_dpsum > max_sum){  //更新最小子矩阵
	                        max_sum = dpsum-min_dpsum;
	                        ans[0] = r1;
	                        ans[1] = min_dpsum_index+1;
	                        ans[2] = r2;
	                        ans[3] = c2;
	                    }
	                    if(dpsum < min_dpsum){  //更新一维问题的最小累加和
	                        min_dpsum = dpsum;
	                        min_dpsum_index = c2;
	                    }
	                }
	            }
	        }
	        return ans;
	    }
	}