# 687. 最长同值路径 #
思路：这题hard也不为过，太难了

	
	class Solution {
	    int ans;
	    public int longestUnivaluePath(TreeNode root) {
	        ans = 0;
	        pathSum(root);
	        return ans;
	    }
	
	    public int pathSum(TreeNode root){
	        if(root == null) return 0;
	        int left = pathSum(root.left);
	        int right = pathSum(root.right);
	        int leftR = 0,rightR = 0;
	        if(root.left != null && root.val == root.left.val){
	            leftR += 1 + left;
	        }
	        if(root.right != null && root.val == root.right.val){
	            rightR += 1 + right;
	        }
	        ans = Math.max(ans,leftR + rightR);
	        return Math.max(leftR,rightR);
	    }
	}
# 面试题 04.05. 合法二叉搜索树 #
思路：比较左子树和结点，右子树和结点值的大小
问题：样例【1，null,1】  无法处理


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
      if(root==null) return true;
        return isValidBSThelp(root.left,Long.MIN_VALUE,root.val)&&isValidBSThelp(root.right,root.val,Long.MAX_VALUE);
    }
    private boolean isValidBSThelp(TreeNode root,long min,long max){
        if(root==null) return true;
        if(root.val<=min||root.val>=max) return false;
        boolean left = isValidBSThelp(root.left,min,root.val);
        boolean right = isValidBSThelp(root.right,root.val,max);
        return left && right;
    }


}