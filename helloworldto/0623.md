# LCP 07. 传递信息 #
思路：使用hashmap,key是A，value是A传递信息的B的集合

	class Solution {
	    private int count = 0;
	    public int numWays(int n, int[][] relation, int k) {
	        Map<Integer,List<Integer>> map = new HashMap<>();
	        for(int[] temp : relation){
	            if(!map.containsKey(temp[0]))
	                map.put(temp[0],new ArrayList<>());
	            map.get(temp[0]).add(temp[1]);
	        }
	        backTracking(map,k,n,0,0);
	        return count;
	    }
	
	    private void backTracking(Map<Integer,List<Integer>>map,int k,int n, int index,int cur){
	        if(index == k){
	            if(cur == n -1) count++;
	            return;
	        }
	        if(!map.containsKey(cur)) return;
	        for(int i : map.get(cur))
	            backTracking(map,k,n,index+1,i);
	    }
	
	
	}

# 79. 单词搜索 #
思路： 递归
	
	class Solution {
	    public boolean exist(char[][] board, String word) {
	        char[] data = word.toCharArray();
	        int index1 = 0;
	        int index2 = 0;
	        for(int i = 0; i < board.length;i++){
	            for(int j = 0; j < board[0].length;j++){
	                if(data[0] == board[i][j]){
	                    index1 = i;
	                    index2 = j;
	                    break;
	                }
	            }
	        }
	
	        return Search(board,data,index1,index2,data.length-1);
	    }
	
	    public boolean Search(char[][] board,char[]data,int i,int j,int length){
	        if(length == 0) return true;
	        boolean flag1 = true;
	        boolean flag2 = true;
	        boolean flag3 = true;
	        boolean flag4 = true;
	
	        if(i -1 >= 0 && board[i-1][j] == data[data.length-length])  flag1 = Search(board,data,i-1,j,length-1);
	        if(i + 1 < board.length && board[i+1][j] == data[data.length-length])flag2 = Search(board,data,i+1,j,length-1);
	        if(j-1 >= 0 && board[i][j-1] == data[data.length-length]) flag3 = Search(board,data,i,j-1,length-1);
	        if(j + 1 < board[0].length && board[i][j+1] == data[data.length-length]) flag4 = Search(board,data,i,j+1,length-1);
	        return flag4&& flag3&& flag2&& flag1;
	    }
	}


问题：不能重复 还需要考虑集合

	 public static  boolean exist(char[][] board, String word) {
	        char[] data = word.toCharArray();
	        boolean[][] isVisited = new boolean[board.length][board[0].length];
	        List<Integer[]> list = new ArrayList<>();
	        for(int i = 0; i < board.length;i++){
	            for(int j = 0; j < board[0].length;j++){
	                if(data[0] == board[i][j]){
	                    //isVisited[i][j] = true;
	                    Integer[] num = new Integer[2];
	
	                    num[0] = i;
	                    num[1] = j;
	                    list.add(num);
	                }
	            }
	        }
	        boolean flag = false;
	        for(int i = 0; i < list.size();i++){
	            Integer[] num = list.get(i);
	            isVisited[num[0]][num[1]] = true;
	            flag = flag ||Search(board,data,isVisited, num[0],num[1],data.length-1);
	        }
	        return flag;
	    }
	
	    public static boolean Search(char[][] board,char[]data,boolean[][] isVisited,int i,int j,int length){
	        if(length == 0) return true;
	        boolean flag1 = false;
	        boolean flag2 = false;
	        boolean flag3 = false;
	        boolean flag4 = false;
	        if(i -1 >= 0 && !isVisited[i-1][j] &&board[i-1][j] == data[data.length-length])  {
	            isVisited[i-1][j] = true;
	            flag1 = Search(board,data,isVisited,i-1,j,length-1);
	
	
	        }
	        if(i + 1 < board.length&& !isVisited[i+1][j] && board[i+1][j] == data[data.length-length]){
	            isVisited[i+1][j] = true;
	
	            flag2 = Search(board,data,isVisited,i+1,j,length-1);
	
	        }
	        if(j-1 >= 0 && !isVisited[i][j-1]&& board[i][j-1] == data[data.length-length]){
	            isVisited[i][j-1] = true;
	
	            flag3 = Search(board,data,isVisited,i,j-1,length-1);
	
	        }
	        if(j + 1 < board[0].length&& !isVisited[i][j+1]&&board[i][j+1] == data[data.length-length]) {
	            isVisited[i][j+1] = true;
	
	            flag4 = Search(board,data,isVisited,i,j+1,length-1);
	
	        }
	        return flag4 || flag3|| flag2|| flag1;
	    }


问题：重复考虑错误 应使用hashset

class Solution {
   public   boolean exist(char[][] board, String word) {
        char[] data = word.toCharArray();
        List<Integer[]> list = new ArrayList<>();
        Set<Integer[]> set = new HashSet<>();
        for(int i = 0; i < board.length;i++){
            for(int j = 0; j < board[0].length;j++){
                if(data[0] == board[i][j]){
                    //isVisited[i][j] = true;
                    Integer[] num = new Integer[2];

                    num[0] = i;
                    num[1] = j;
                    list.add(num);
                    
                }
            }
        }
        boolean flag = false;
        for(int i = 0; i < list.size();i++){
            Integer[] num = list.get(i);
            set.add(num);
            flag = Search(board,data,set, num[0],num[1],data.length-1);
            if(flag) return true;
        }
        return flag;
    }

    public  boolean Search(char[][] board,char[]data, Set<Integer[]> set,int i,int j,int length){
         if(length == 0) return true;
        boolean flag1 = false;
        boolean flag2 = false;
        boolean flag3 = false;
        boolean flag4 = false;
        if(i -1 >= 0  &&board[i-1][j] == data[data.length-length])  {
            Integer[] num = new Integer[2];

            num[0] = i-1;
            num[1] = j;
            if(!set.contains(num))  {
                set.add(num);
                flag1 = Search(board,data,set,i-1,j,length-1);
                if(flag1) return true;
            }


        }
        if(i + 1 < board.length && board[i+1][j] == data[data.length-length]){
            Integer[] num = new Integer[2];

            num[0] = i+1;
            num[1] = j;
            if(!set.contains(num))  {
                set.add(num);
                flag2 = Search(board,data,set,i+1,j,length-1);
                if(flag2) return true;

            }


        }
        if(j-1 >= 0 && board[i][j-1] == data[data.length-length]){
            Integer[] num = new Integer[2];

            num[0] = i;
            num[1] = j-1;
            if(!set.contains(num))  {
                set.add(num);
                flag3 = Search(board,data,set,i,j-1,length-1);
                if(flag3) return true;

            }


        }
        if(j + 1 < board[0].length&&board[i][j+1] == data[data.length-length]) {
            Integer[] num = new Integer[2];

            num[0] = i;
            num[1] = j+1;
            if(!set.contains(num))  {
                set.add(num);
                flag4 = Search(board,data,set,i,j+1,length-1);
                if(flag4) return true;

            }

        }
        return flag4 || flag3|| flag2|| flag1;
    }
}

问题：Hashset比较的是数组的地址
