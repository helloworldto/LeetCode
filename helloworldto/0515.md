

思路:中序遍历，先用arraylist保存树，然后找众数，问题：效率太慢，而且不知道数组长度

	/**
	 * Definition for a binary tree node.
	 * public class TreeNode {
	 *     int val;
	 *     TreeNode left;
	 *     TreeNode right;
	 *     TreeNode(int x) { val = x; }
	 * }
	 */
	class Solution {
	    Arraylist<Integer> list = new Arraylist<>();
	    public int[] findMode(TreeNode root) {
	        Search(root);
	        Integer value = null;
	        int count = 0;
	        if(list.size() == 1) {
	            int[] res = new int[1];
	            res[0] = list.get(0);
	            return res;
	        }
	        int max = 0;
	        for (int i= 1; i<list.size(); i++) {
	            if(list.get(i) == list.get(i-1)){
	                count++;
	            }else{
	                if(max < count){
	                    max = count;
	                }
	                count = 1;
	            }        
	        }
	
	        for(int i = 0; i < list.size;i++){
	            if(list.get(i)== 0;i < list.size();i++){
	                if(list.get(i) == list.get(i-1)){
	                    count++;
	                    if(count == max){
	                        
	                    }
	                }
	            }
	        }
	        
	    }
	
	    public void Search(TreeNode root){
	        if(root == null) return null;
	        if(root.left != null) Search(root.left);
	        list.add(root.val);
	        if(root.right != null) Search(root.right);
	    }
	}


改进：直接用arrylist保存众数，这样需要做到在arraylist保存的就是众数，需要另外的索引记录众数，如果出现更多次数的数，先将arraylist清空，再将新的众数加进去

	class Solution {
	    List<Integer> list = new LinkedList<Integer>();
	    TreeNode pre = null;
	    int max = 0;
	    int index = 0;
	    public int[] findMode(TreeNode root) {
	        inOrder(root);
	        int len = list.size();
	        int[] res = new int[len];
	        for(int i = 0; i < len; i++){
	            res[i] = list.get(i);
	        }
	        return res;
	    }
	    public void inOrder(TreeNode root){
	        if(root == null) return;
	        inOrder(root.left);
	        if(pre != null && pre.val == root.val){
	            index++;
	        }else{
	            index  = 1;
	        }
	        if(index == max) list.add(root.val);
	        else if(index > max){
	            max = index;
	            list.clear();
	            list.add(root.val);
	        }
	        pre = root;
	        inOrder(root.right);    
	    }
	}

# 94. 二叉树的中序遍历 #


	class Solution {
	    List<Integer> list = new ArrayList<>();
	
	    public List<Integer> inorderTraversal(TreeNode root) {
	        if(root == null)
	            return list;
	        if(root.left != null)
	            inorderTraversal(root.left);
	        list.add(root.val);
	        if(root.right != null)
	            inorderTraversal(root.right);
	        return list;
	    }
	}

# 65. 有效数字 #
思路： 参考大佬，分情况讨论，判断每一个字符的情况

	class Solution {
	    public boolean isNumber(String s) {
	        if(s==null||s.length()==0) return false;
	        boolean numSeen=false;
	        boolean dotSeen=false;
	        boolean eSeen=false;
	        char arr[]=s.trim().toCharArray();
	        for(int i=0; i<arr.length; i++){
	            if(arr[i]>='0'&&arr[i]<='9'){
	                numSeen=true;
	            }else if(arr[i]=='.'){
	                if(dotSeen||eSeen){
	                    return false;
	                }
	                dotSeen=true;
	            }else if(arr[i]=='E'||arr[i]=='e'){
	                if(eSeen||!numSeen){
	                    return false;
	                }
	                eSeen=true;
	                numSeen=false;
	            }else if(arr[i]=='+'||arr[i]=='-'){
	                if(i!=0&&arr[i-1]!='e'&&arr[i-1]!='E'){
	                    return false;
	                }
	            }else{
	                return false;
	            }
	        }
	        return numSeen;
	
	
	
	    }
	}
