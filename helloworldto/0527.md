# 20. 有效的括号 #
思路：辅助栈和hashmap,hashmap存放键值对，栈存放左左括号

	class Solution {
	    public boolean isValid(String s) {
	        //栈
	         Stack<Character> stack = new Stack<>();
	        int len = s.length();
	        if(len % 2 != 0)
	            return false;
	        Map<Character, Character> map = new HashMap<>();
	        map.put('(', ')');
	        map.put('{', '}');
	        map.put('[', ']');
	        for(int i = 0; i < len; i++){
	             char c = s.charAt(i);
	
	            if (c == '(' || c == '[' || c == '{'){            
	                 stack.push(c );
	            }     
	            else{
	                if(stack.isEmpty() || c != map.get(stack.pop())){
	                   return false;
	                }
	
	            }
	        }
	        if(!stack.isEmpty())
	            return false;
	        return true;
	    }
	}

# 22. 括号生成 #
思路：递归剪枝，右括号会受到左括号的限制，如果左右括号都为0，则将该String加入到list中，如果发现left > right 则表明剩下的左括号比右括号多，直接剪枝


	class Solution {
	    public List<String> generateParenthesis(int n) {
	        List<String> list = new ArrayList();
	        if(n == 0)
	            return list;
	        dfs("",n,n, list);
	        return list;
	    }
	
	    public void dfs(String curStr,int left,int right,List<String> list){
	       if(left == 0 && right == 0){
	           list.add(curStr);
	           return;
	       }
	       //剪枝 右括号受到左括号的限制
	       if(left > right){
	           return;
	       }
	       if(left > 0){
	           dfs(curStr + "(" ,left -1,right, list);
	       }
	       if(right > 0){
	           dfs(curStr + ")", left, right-1,list);
	       }
	    }
	}

# 1096. 花括号展开 II #
的、思考z