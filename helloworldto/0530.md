# 1025. 除数博弈 #
思路：如果偶数，a稳赢，如果奇数，b稳赢

	class Solution {
	    public boolean divisorGame(int N) {
	        if(N % 2 == 0) return true;
	        else return false;
	
	    }
	}

# 764. 最大加号标志 #
思路：完全理解错题意。。。 以为输入矩阵已告知


	class Solution {
	    public int orderOfLargestPlusSign(int N, int[][] mines) {
	        int max = 0;
	        int len = mines.length;
	        int high = mines[0].length;
	        for(int i = 0; i < len-max;i++){
	            for(int j = 0; j < high-max;j++){
	                if(mines[i][j] == 1){
	                    if(i == 0 || j == 0 || i ==len -1 ||j == high-1){
	                        if(max == 0) max = 1;
	                    }
	                    else{
	                        boolean flag = true;
	                        int k = 0;
	                        for(k = j+1;k < high;k++){
	                            if(mines[i][k] == 0 || mines[i][high-k] == 0) break;
	                        }
	                        int num = k-j;
	                        for(int m = i - num +1; m < i+num;m++){
	                            if(mines[m][j] != 1) {
	                                flag = false;
	                                break;
	                            }
	                        }
	                        if(flag) max = max > num ? max:num;
	                    }
	                }
	            }
	        }
	        return max;
	    }
	}

实际上给出的是值为0的坐标点  

	
	class Solution {
	    public int orderOfLargestPlusSign(int N, int[][] mines) {
	        int max = 0;
	       
	        int[][] data = new int[N][N];
	        for(int i = 0; i < N;i++){
	            for(int j = 0; j < N;j++){
	                data[i][j] = 1;
	            }
	        }
	        if(mines.length != 0){
	            for(int i = 0; i < mines.length;i++){
	                data[mines[i][0]][mines[i][1]] = 0;
	            }
	        }
	        
	        
	        for(int i = 0; i < N-max;i++){
	            for(int j = 0; j < N-max;j++){
	                if(data[i][j] == 1){
	                    if(i == 0 || j == 0 || i ==N -1 ||j == N-1){
	                        if(max == 0) max = 1;
	                    }
	                    else{
	                        boolean flag = true;
	                        int k = 0;
	                        for(k = j+1;k < N ;k++){
	                            if(data[i][k] == 0 || data[i][N-k] == 0) break;
	                        }
	                        int num = k - j;
	                        for(int m = i - num +1; m < i+num;m++){
	                            if(data[m][j] != 1) {
	                                flag = false;
	                                break;
	                            }
	                        }
	                        if(flag) max = max > num ? max:num;
	                    }
	                }
	            }
	        }
	        return max;
	    }
	}