# 122. 买卖股票的最佳时机 II#
思路：同昨天的，当卖出股票的时候，同时买入

	class Solution {
	    public int maxProfit(int[] prices) {
	        int max = 0;
	        int left = Integer.MAX_VALUE;
	        for(int i = 0; i < prices.length;i++){
	            if(left > prices[i]) left = prices[i];
	            else{
	                max = max + prices[i] - left;
	                left = prices[i]; 
	            }
	        }
	        return max;
	    }
	}

# 378. 有序矩阵中第K小的元素 #

思路：二分查找，找出当前中间值，寻找比该值小或大的个数

	class Solution {
	        public int kthSmallest(int[][] matrix, int k) {
	        int row = matrix.length;
	        int col = matrix[0].length;
	        int left = matrix[0][0];
	        int right = matrix[row - 1][col - 1];
	        while (left < right) {
	            // 每次循环都保证第K小的数在start~end之间，当start==end，第k小的数就是start
	            int mid = (left + right) / 2;
	            // 找二维矩阵中<=mid的元素总个数
	            int count = findNotBiggerThanMid(matrix, mid, row, col);
	            if (count < k) {
	                // 第k小的数在右半部分，且不包含mid
	                left = mid + 1;
	            } else {
	                // 第k小的数在左半部分，可能包含mid
	                right = mid;
	            }
	        }
	        return right;
	    }
	
	    private int findNotBiggerThanMid(int[][] matrix, int mid, int row, int col) {
	        // 以列为单位找，找到每一列最后一个<=mid的数即知道每一列有多少个数<=mid
	        int i = row - 1;
	        int j = 0;
	        int count = 0;
	        while (i >= 0 && j < col) {
	            if (matrix[i][j] <= mid) {
	                // 第j列有i+1个元素<=mid
	                count += i + 1;
	                j++;
	            } else {
	                // 第j列目前的数大于mid，需要继续在当前列往上找
	                i--;
	            }
	        }
	        return count;
	    }

}