# 面试题39. 数组中出现次数超过一半的数字 #

思路：先排序，重复计数，如果计数结果大于数组长度一半则返回

	class Solution {
	    public int majorityElement(int[] nums) {
	        int len = nums.length;
	        Arrays.sort(nums);
	        int count = 0;
	        int res = nums[0];
	        for(int i = 1; i < len;i++){
	            if(nums[i] == nums[i-1]){
	                count++;
	                 if(count >=len/2){
	                    res = nums[i-1];
	                    break;
	                }
	            }else{
	                if(count >=len/2){
	                    res = nums[i-1];
	                    break;
	                }else{
	                    count = 0;
	                }
	
	            }
	        }
	        return res;
	    }
	}

# 面试题63. 股票的最大利润 #
思路:动态规划，有两个值，第一个值是成本，第二个是最大值，我们希望成本最小，最大值尽量大

  			cost = Math.min(cost,prices[i]);
            max = Math.max(max,prices[i] - cost);

全部代码如下：


	class Solution {
	    public int maxProfit(int[] prices) {
	        //动态规划
	        int max = 0;
	        int cost = Integer.MAX_VALUE;
	        int[] dp = new int[prices.length];
	        for(int i = 0; i < prices.length;i++){
	            cost = Math.min(cost,prices[i]);
	            max = Math.max(max,prices[i] - cost);
	            
	        }
	        return max;
	    }
	}

# 233. 数字 1 的个数 #

**思路： 还没弄明白**
	
	class Solution {
	    public int countDigitOne(int n) {
	        //1 10 11 12 13 14 15 16 17 18 19 21 31 41 51 61 71 81 91 100 101 102 103
	        int count = 0;
	        int sum = 0;
	        int sumt = 0;
	        int num = n;
	        int res = 0;
	        while(num>0){
	            //当前位大小
	            int digit = num%10;
	            if(digit==1){
	                sumt = n - n/(int)Math.pow(10,count)*(int)Math.pow(10,count)+1+sumt+sum;
	            }else if(digit>1){
	                sumt = sum*digit + (int)Math.pow(10,count) + sumt;
	            }
	            sum = sum*10 + (int)Math.pow(10,count);
	            count++;
	            num = num/10;
	            
	        }
	        return sumt;
	
	    }
	}

