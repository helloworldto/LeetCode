# 746. 使用最小花费爬楼梯 #
思路：动态规划

	class Solution {
	    public int minCostClimbingStairs(int[] cost) {
	         int f1 = 0, f2 = 0;
	        for (int i = cost.length - 1; i >= 0; --i) {
	            int f0 = cost[i] + Math.min(f1, f2);
	            f2 = f1;
	            f1 = f0;
	        }
	        return Math.min(f1, f2);
	    }
	}

# 718. 最长重复子数组 # 
思路：其实应该是滑动窗口

	class Solution {
	    public int findLength(int[] A, int[] B) {
	        int len1 = A.length;
	        int len2 = B.length;
	        int max = 0;
	        int k = 0;
	        int m = 0;
	        int index = 0;
	        for(int i = 0; i < len1;i++){
	            index = 0;
	            for(int j= 0; j < len2;j++){
	                if(A[i] == B[j]){
	                    index++;
	                    k = i+1;
	                    m = j+1;
	                    break;
	                } 
	            }
	            while(k < len1 && m < len2 && A[k++] == B[m++]){index++;}
	            max = max > index? max: index;
	        }
	        return max;
	    }
	}

大佬做法  动态规划
	
	class Solution {
	    public int findLength(int[] A, int[] B) {
	        int ans = 0;
	        int[][] memo = new int[A.length + 1][B.length + 1];
	        for (int i = A.length - 1; i >= 0; --i) {
	            for (int j = B.length - 1; j >= 0; --j) {
	                if (A[i] == B[j]) {
	                    memo[i][j] = memo[i+1][j+1] + 1;
	                    if (ans < memo[i][j]) ans = memo[i][j];
	                }
	            }
	        }
	        return ans;
	    }
	}


# 123. 买卖股票的最佳时机 III #
简单思路：设置含有两个元素的数组，然后进行买入股票 如果大于当前数组中某一个元素 则进行替换

class Solution {
    public int maxProfit(int[] prices) {
        int[] data = new int[2];
        //先将所有的利润算出来 然后计算两个最大的
        int cost = Integer.MAX_VALUE;
        for(int i = 0; i < prices.length;i++){
            if(prices[i] < cost) cost = prices[i];
            else {
                if((i+1 < prices.length && prices[i+1] < prices[i])|| i+1== prices.length){
                    int sum = prices[i] - cost;
                    cost = prices[i];
                    if(sum > data[0] && sum > data[1]) {
                        if(data[0] < data[1]) data[0] = sum;
                        else data[1] = sum;
                    }
                    else if(sum > data[0])  data[0] = sum;
                    else if(sum > data[1]) data[1] = sum;
                }
                    
            }
        }
        return data[0] + data[1];


    }
}

问题：

	输入:
	[1,2,4,2,5,7,2,4,9,0]
	输出
	12
	预期结果
	13