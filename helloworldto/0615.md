# 141. 环形链表#
思路：使用set保存结点，有重复的则返回

	public class Solution {
	    public boolean hasCycle(ListNode head) {
	        Set<ListNode> set = new HashSet<ListNode>();
	        while(head!= null){
	            if(set.contains(head)){
	                return true;
	            }
	            set.add(head);
	            head =head.next;
	        }
	        return false;
	    }
	}

# 47. 全排列 II #
思路：全排列 交换

	class Solution {
	    public List<List<Integer>> permuteUnique(int[] nums) {
	        List<List<Integer>> output = new LinkedList();
	        ArrayList<Integer> list = new ArrayList();
	    
	        for(int num : nums)
	            list.add(num);
	
	    
	        
	        int n = nums.length;
	        backtrack(n,list,output,0);
	        return output;
	    }
	
	    public boolean isRepeat(ArrayList<Integer>list,int first,int i){
	        int temp = list.get(i);
	        for(int j = first; j < i; j++){
	            if(list.get(j) == temp)
	                return true;
	        }
	        return false;
	    }
	
	    public void backtrack(int n, ArrayList<Integer>list,List<List<Integer>> output,int first){
	        if(n == first){
	            output.add(new ArrayList<Integer> (list));
	            return;
	        }
	        for(int i = first; i < n; i++){
	            if(!isRepeat(list,first,i)){
	                 Collections.swap(list,first,i);
	                 backtrack(n,list,output,first+1);
	            
	                Collections.swap(list,first,i);
	            }
	           
	          
	        }
	    }
	}

