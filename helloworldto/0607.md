  # 507. 完美数 #
思路：求因子，然后计算结果  超时

	class Solution {
	    public boolean checkPerfectNumber(int num) {
	        List<Integer> list = new ArrayList<Integer>();
	        for(int i =1; i <= num/2;i++){
	            if(num%i  == 0) list.add(i);
	        }
	        for(int i = 0; i < list.size();i++){
	            num -= list.get(i);
	        }
	
	        return num == 0;
	    }
	}


改进

	class Solution {
    public boolean checkPerfectNumber(int num) {
        int sum = 1;
        for(int i =2; i <= num/2;i++){
            if(num%i  == 0) sum += i;
        }
      

        return num == sum;
    }
}

超时

改进：欧几里得-欧拉定理
	
	6 = 2^1 * (2^2 - 1)
	28 = 2^2 * (2^3 - 1)
	496 = 2^3 * (2^4 - 1)
	8128 = 2^4 * (2^5 - 1)



代码：

	public class Solution {
	    public int pn(int p) {
	        return (1 << (p - 1)) * ((1 << p) - 1);
	    }
	    public boolean checkPerfectNumber(int num) {
	        int[] primes=new int[]{2,3,5,7,13,17,19,31};
	        for (int prime: primes) {
	            if (pn(prime) == num)
	                return true;
	        }
	        return false;
	    }
	}

# 869. 重新排序得到 2 的幂 #
思路：参考大佬思路  使用Arrays.equals比较N和2的幂的构成


	class Solution {
	    public boolean reorderedPowerOf2(int N) {
	        int[] A = count(N);
	        for (int i = 0; i < 31; ++i)
	            if (Arrays.equals(A, count(1 << i)))
	                return true;
	        return false;
	    }
	
	    // Returns the count of digits of N
	    // Eg. N = 112223334, returns [0,2,3,3,1,0,0,0,0,0]
	    public int[] count(int N) {
	        int[] ans = new int[10];
	        while (N > 0) {
	            ans[N % 10]++;
	            N /= 10;
	        }
	        return ans;
	    }
	}

# 458. 可怜的小猪 #
参考大佬，数学题
	class Solution {
	    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
	        int states = minutesToTest / minutesToDie + 1;
	        return (int) Math.ceil(Math.log(buckets) / Math.log(states));
	    }
	}
