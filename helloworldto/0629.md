
# 剑指 Offer 04. 二维数组中的查找 #
思路：两层循环

	class Solution {
	    public boolean findNumberIn2DArray(int[][] matrix, int target) {
	        for(int i = 0; i < matrix.length;i++){
	            for(int j = 0; j < matrix[0].length;j++){
	                if(matrix[i][j] > target) {
	                    if(i !=matrix.length-1 && j != 0) continue; 
	                    else return false;
	                }
	                else if(matrix[i][j] == target) return true;
	            
	            }
	        }
	        return false;
	    }
	}

# 907. 子数组的最小值之和 #
思路：使用栈
	
	class Solution {
	    int MOD = 1000000007;
	
	    public int sumSubarrayMins(int[] A) {
	        Stack<Pair> stack = new Stack<>();
	        int res = 0, tmp = 0;
	        for (int i = 0; i < A.length; i++) {
	            int count = 1;
	            while (!stack.empty() && stack.peek().val >= A[i]) {
	                Pair pop = stack.pop();
	                count += pop.count;
	                tmp -= pop.val * pop.count;
	            }
	            stack.push(new Pair(A[i], count));
	            tmp += A[i] * count;
	            res += tmp;
	            res %= MOD;
	        }
	        return res;
	    }
	}
	
	class Pair {
	    public int val;
	    public int count;
	
	    public Pair(int val, int count) {
	        this.val = val;
	        this.count = count;
	    }
	}
