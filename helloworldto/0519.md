# 9. 回文数 #
思路：将整数转为字符串，使用栈保存前半段字符串，与后半段进行比较

	class Solution {
	    public boolean isPalindrome(int x) {
	        Stack<Integer> stack = new Stack<>();
	        if(x < 0)
	            return false;
	        String a = x + "";
	        for(int i = 0; i < a.length()/2; i++){
	            if(a.charAt(i)!= a.charAt(a.length() -i-1))
	                return false;
	        }
	        return true;
	    }
	}

# 5. 最长回文子串 #
思路：暴力破解
	
	class Solution {
	    public String longestPalindrome(String s) {
	        int max = 0;
	        String ans = "";
	        for(int i = 0; i < s.length();i++){
	            for(int j = i+1; j <= s.length();j++){
	                String str = s.substring(i,j);
	                if(isPalindrome(str) && str.length() > max){
	                    ans = s.substring(i,j);
	                    max = Math.max(max,ans.length());
	                }
	            }
	        }
	        return ans;
	    }
	      public boolean isPalindrome(String str) {
	          if(str.length() == 1) return true;
		        Stack<Integer> stack = new Stack<>();
	
		        for(int i = 0; i < str.length()/2; i++){
		            if(str.charAt(i)!= str.charAt(str.length() -i-1))
		                return false;
		        }
		        return true;
		    }
	}

错误：超出时间限制
改进： 因为要长最长子串，因此可以将原子串翻转

	class Solution {
	    public String longestPalindrome(String s) {
	    if (s.equals(""))
	        return "";
	    String origin = s;
	    String reverse = new StringBuffer(s).reverse().toString();
	    int length = s.length();
	    int[][] arr = new int[length][length];
	    int maxLen = 0;
	    int maxEnd = 0;
	    for (int i = 0; i < length; i++)
	        for (int j = 0; j < length; j++) {
	            if (origin.charAt(i) == reverse.charAt(j)) {
	                if (i == 0 || j == 0) {
	                    arr[i][j] = 1;
	                } else {
	                    arr[i][j] = arr[i - 1][j - 1] + 1;
	                }
	            }
	          
	            if (arr[i][j] > maxLen) {
	                int beforeRev = length - 1 - j;
	                if (beforeRev + arr[i][j] - 1 == i) { //判断下标是否对应
	                    maxLen = arr[i][j];
	                    maxEnd = i;
	                }
	            
	            }
	        }
	    return s.substring(maxEnd - maxLen + 1, maxEnd + 1);
		}
	
	
	
	}

# 124. 二叉树中的最大路径和 #
思路：仍有错误，递归，注意子树和是否小于0
	class Solution {
	    public int maxPathSum(TreeNode root) {
	        if(root == null) return 0;
	        if(root.left == null && root.right== null) return root.val;
	        if(root.left == null) 
	            if(root.val > 0)return root.val +Math.max( maxPathSum(root.right),0);
	            else return maxPathSum(root.right);
	        if(root.right == null)
	            if(root.val > 0) return root.val + Math.max(maxPathSum(root.left),0);
	            else return maxPathSum(root.left);
	        if(root.val < 0){
	            if(root.left != null)
	                if(maxPathSum(root.left) + root.val < 0) return maxPathSum(root.right);
	                else return root.val + Math.max(maxPathSum(root.left),0)+Math.max(maxPathSum(root.right),0);
	            if(root.right != null)
	                if(maxPathSum(root.right) + root.val < 0) return maxPathSum(root.left);
	                else return   root.val + Math.max(maxPathSum(root.left),0)+Math.max(maxPathSum(root.right),0);
	        }else{
	            return root.val + Math.max(maxPathSum(root.left),0)+Math.max(maxPathSum(root.right),0);        
	            }
	        return 0;
	    }
	}