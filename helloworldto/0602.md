# 121. 买卖股票的最佳时机 #
思路：暴力/动态规划

	class Solution {
	    public int maxProfit(int[] prices) {
	        int max = 0;
	        for(int i = 0; i < prices.length;i++){
	            for(int j = i+1; j < prices.length;j++){
	                if(prices[j] - prices[i] > max)
	                    max = prices[j] - prices[i];
	            }
	        }
	        return max > 0 ? max: 0;
	    }
	}


	class Solution {
	    public int maxProfit(int[] prices) {
	           int minprice = Integer.MAX_VALUE;
	        int maxprofit = 0;
	        for (int i = 0; i < prices.length; i++) {
	            if (prices[i] < minprice)
	                minprice = prices[i];
	            else if (prices[i] - minprice > maxprofit)
	                maxprofit = prices[i] - minprice;
	        }
	        return maxprofit;
	
	    }
	}


# 547. 朋友圈 #
思路：参考 深度优先  如果结束一次朋友圈+1

	class Solution {
	    public int findCircleNum(int[][] M) {//统计无向图的连通分量的个数
	        int res=0;
	        int n=M.length;//n个顶点
	        boolean [] visited=new boolean[n];//Java默认false
	        for(int i=0;i<n;i++){
	            if(!visited[i]){//当前节点未被访问过,可从它开始dfs
	                dfs(M,visited,i);
	                res+=1;//主循环里每一次dfs出来就遍历完一个连通子图
	            }
	        }
	        return res;
	    }
	    public void dfs(int[][] M,boolean [] visited,int i){
	        if(visited[i]) return;//当前节点已被访问过
	        visited[i]=true;
	        for(int j=0;j<M.length;j++){
	            if(M[i][j]==1) dfs(M,visited,j);
	        }
	    }
	}


