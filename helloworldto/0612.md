# 面试题10- I. 斐波那契数列 #
思路：递归（超时） 动态规划，用for循环和数组保存原来的计算结果

	class Solution {
	    public int fib(int n) {
	          if(n == 0)
	            return 0;
	        int[] result = new int[n + 1];
	        result[1] = 1;
	        for(int i = 2; i <= n; i++)
	            result[i] = (result[i - 2] + result[i - 1])  % 1000000007;
	        return result[n];
	
	    }
	}

# 1143. 最长公共子序列 #
思路：动态规划 返回最大的公共子序列，如果i-1,j-1处两个元素相同，则i j位置上的值为当前位置+1，否则为动态数组中两个中较大的值


	class Solution {
	    public int longestCommonSubsequence(String text1, String text2) {
	      char[] t1 = text1.toCharArray();
	        char[] t2 = text2.toCharArray();
	        int length1 = t1.length;
	        int length2 = t2.length;
	        int[][] dp = new int[length1+1][length2+1];
	        for (int i = 1; i < length1 +1; i++) {
	            for (int j = 1; j < length2 +1; j++) {
	                if (t1[i-1] == t2[j-1]){
	                    // 这边找到一个 lcs 的元素，继续往前找
	                    dp[i][j] = 1+ dp[i-1][j-1];
	                }else {
	                    //谁能让 lcs 最长，就听谁的
	                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
	                }
	            }
	        }
	        return dp[length1][length2];
	    }
	}

