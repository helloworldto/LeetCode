# 234. 回文链表 #

思路：两次，第一次查询长度，第二次用栈保存前半部分的数据和后半部分的进行比较
	
	class Solution {
	    public boolean isPalindrome(ListNode head) {
	        if(head == null) return true;
	        if(head.next == null) return true;
	        ListNode tmp = head;
	        int len = 0;
	        while(tmp != null){
	            len++;
	            tmp = tmp.next;
	        }
	        tmp = head;
	        Stack<Integer> stack = new Stack<Integer>();
	        for(int i = 0; i < len/2; i++){
	            stack.push(tmp.val);
	            tmp= tmp.next;
	        }
	        if(len %2 != 0) tmp = tmp.next;
	        while(tmp!=null){
	            if(stack.pop() != tmp.val) return false;
	            tmp = tmp.next;
	        }
	        return true;
	    }
	}

# 162. 寻找峰值 #
思路：判断数组长度是否为1，是返回0，判断当前元素和前一个后一个元素的大小，如果当前元素大于前一个后一个元素，则当前元素就可能是峰值。判断倒数第二倒数第一个元素的大小，如果倒数第一个元素大于倒数第二个元素，则比较当前元素和倒数第一个元素的大小，返回较大的那个索引

	class Solution {
	    public int findPeakElement(int[] nums) {
	       if (nums.length == 1) return 0;
	        int max = 0;
	        for(int i = 1; i < nums.length-1;i++){
	            if(nums[i] > nums[i-1] && nums[i] > nums[i+1]) {
	                max = i;
	                break;
	            }
	        }
	        if(nums[nums.length-2] < nums[nums.length-1]) max = nums[max] > nums[nums.length-1]?max:nums.length-1;
	        return max;
	    }
	}

# 329. 矩阵中的最长递增路径 #
思路：动态规划，当前位置等于当前位置相邻的上下左右小于它的个数+max上下左右

	class Solution {
	
	    public int longestIncreasingPath(int[][] matrix) {
	         if(matrix.length == 0) return 0;
	         int max = 0;
	        int[][] dp = new int[matrix.length][matrix[0].length];
	
	        for(int i = 0; i < matrix.length;i++){
	            for(int j = 0;j < matrix[0].length;j++){
	                if(dp[i][j] == 0) dfs(i,j,matrix,dp);
	            }
	        }
	       
	       for(int[] data:dp){
	           for(int num : data){
	               if(max < num)
	                    max = num;
	           }
	       }
	       return max +1;
	    }
	
	    public int dfs(int i,int j,int[][] matrix,int[][]dp){
	         if(dp[i][j] != 0) return dp[i][j];
	    	int num = 0;
	        int left = 0,right = 0,up = 0,down = 0;
	        if(i -1 >= 0 && matrix[i-1][j] < matrix[i][j]) {
	            up = dfs(i-1, j, matrix, dp)+1;
	        }
	         if(i + 1 < matrix.length && matrix[i+1][j] < matrix[i][j]) {
	            down = dfs(i+1,j,matrix,dp)+1;
	        }
	         if(j - 1 >= 0 && matrix[i][j-1] < matrix[i][j]) {
	            left = dfs(i,j-1,matrix,dp)+1;
	        }
	         if(j + 1 < matrix[0].length && matrix[i][j+1] <matrix[i][j]) {
	            right = dfs(i,j+1,matrix,dp)+1;
	        }
	        left = Math.max(Math.max(left,right),Math.max(up,down));
	        dp[i][j] += left;
	        dp[i][j] +=num;
	
	        return dp[i][j];
	       }
	    
	}

改进每次搜索 记忆话搜索 增加boolean类型二维数组，验证当前位置元素是否已经访问过
	
	class Solution {
	
	    public int longestIncreasingPath(int[][] matrix) {
	         if(matrix.length == 0) return 0;
	         int max = 0;
	        int[][] dp = new int[matrix.length][matrix[0].length];
	        boolean[][] flag = new boolean[matrix.length][matrix[0].length];
	        for(int i = 0; i < matrix.length;i++){
	            for(int j = 0;j < matrix[0].length;j++){
	                if(dp[i][j] == 0 && !flag[i][j]) {
	                    dfs(i,j,matrix,dp,flag);
	                    flag[i][j] = true;
	                }
	            }
	        }
	       
	       for(int[] data:dp){
	           for(int num : data){
	               if(max < num)
	                    max = num;
	           }
	       }
	       return max +1;
	    }
	
	    public int dfs(int i,int j,int[][] matrix,int[][]dp,boolean[][]flag){
	         if(flag[i][j]) return dp[i][j];
	    	int num = 0;
	        int left = 0,right = 0,up = 0,down = 0;
	        if(i -1 >= 0 && matrix[i-1][j] < matrix[i][j]) {
	            up = dfs(i-1, j, matrix, dp,flag)+1;
	        }
	         if(i + 1 < matrix.length && matrix[i+1][j] < matrix[i][j]) {
	            down = dfs(i+1,j,matrix,dp,flag)+1;
	        }
	         if(j - 1 >= 0 && matrix[i][j-1] < matrix[i][j]) {
	            left = dfs(i,j-1,matrix,dp,flag)+1;
	        }
	         if(j + 1 < matrix[0].length && matrix[i][j+1] <matrix[i][j]) {
	            right = dfs(i,j+1,matrix,dp,flag)+1;
	        }
	        left = Math.max(Math.max(left,right),Math.max(up,down));
	        dp[i][j] += left;
	        dp[i][j] +=num;
	        flag[i][j] = true;
	        return dp[i][j];
	       }
	    
	}