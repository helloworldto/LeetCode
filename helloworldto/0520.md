# 463. 岛屿的周长 #
思路：计算公式 如果该位置上下左右都为0 则周长为4，如果有三个位置为0，周长3，以此类推

	class Solution {
	    public int islandPerimeter(int[][] grid) {
	        int one = 0;  //一个方位有1
	        int four = 0; //四个方位都有1
	        int three = 0;//三个方位都有1 
	
	        int two = 0;//两个方位有1
	        for(int i = 0; i < grid.length;i++){
	            for(int j = 0; j < grid[0].length;j++){
	                
	                if(grid[i][j] == 1){
	                    int num = 0;
	                    if(i -1 >= 0 && grid[i-1][j] == 1) num++;
	                    if(i+1 < grid.length && grid[i+1][j] == 1) num++;
	                    if(j-1 >= 0 && grid[i][j-1] == 1) num++;
	                    if(j+1 < grid[0].length && grid[i][j+1]==1) num++;
	                    if(num == 0) return 4;
	                    if(num == 1) one++;
	                    if(num == 2) two++;
	                    if(num == 3) three++;
	                    if(num == four) four++;
	                }
	            }
	        }
	        return one*3+three+two*2;
	
	    }
	}

# 701. 二叉搜索树中的插入操作 #
思路：简单的方法，递归查询，没有使用平衡二叉树。如果结点为空，直接返回新结点，如果当前结点值小于val并且当前结点左子树为Null，直接给左子树赋值，以此类推

	class Solution {
	    public TreeNode insertIntoBST(TreeNode root, int val) {
	        if(root == null) return new TreeNode(val);
	        if(root.left == null && root.val >val)  root.left = new TreeNode(val);
	        if(root.right == null && root.val < val) root.right = new TreeNode(val);
	        if(root.val < val) insertIntoBST(root.right,val);
	        if(root.val > val) insertIntoBST(root.left,val);
	        return root;
	    }
	}

# 1335. 工作计划的最低难度 #
思路：最后一天必须是最后一个，剩下的是最小难度。错误：
忽略了最小难度，求成了最大难度

最后一天不一定只完成最后一个
	class Solution {
	    public int minDifficulty(int[] jobDifficulty, int d) {
	        if(jobDifficulty.length < d) return -1;//无法制定满足条件的计划表
	        //问题转化为从前n-1个数中取出前K个最大值，然后加上最后一天的值
	        int len = jobDifficulty.length;
	        int max = jobDifficulty[len -1];
	        
	        for(int i = 0; i < d-1;i++){
	            int num = i;
	            for(int j = i+1;j < len-1;j++){
	                if(jobDifficulty[num] < jobDifficulty[j])
	                    num = j;
	            }
	           
	            max += jobDifficulty[num];
	             if(num != i){
	                jobDifficulty[num] = jobDifficulty[i];
	            }
	        }
	        return max;
	    }
	}


改正：应该是动态规划  参考大佬

	class Solution {
	    public int minDifficulty(int[] jobDifficulty, int d) {
	        if(jobDifficulty.length < d) return -1;//无法制定满足条件的计划表
	        int len = jobDifficulty.length;
	        int job = 0;
	        int[][] dp = new int[d][len];
	        for(int i = 0; i < len;i++){
	            job = Math.max(job,jobDifficulty[i]);
	            dp[0][i] = job;
	        }
	        for(int k = 1; k < d;k++){
	            for(int num = k; num < len;num++){
	                dp[k][num] = Integer.MAX_VALUE;
	                int temp = 0;
	                for(int n = num; n>= k;n--){
	                    temp = Math.max(temp,jobDifficulty[n]);
	                    dp[k][num] = Math.min(dp[k-1][n-1] + temp,dp[k][num]);
	                }
	            }
	            
	        }
	        return dp[d-1][len-1];
	    }
	}
