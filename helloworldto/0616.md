# 997. 找到小镇的法官 #
思路：设置N大小的数组，查找是否有N-1大小的元素，注意当元素大小为N-1时，需要去原数组中查询a是否为N-1，如果a为N-1，则不是我们要找的法官（法官不相信任何人）

注意 使用Set无法解决trust非顺序排列的问题

	class Solution {
	    public int findJudge(int N, int[][] trust) {
	        // if(N==1) return 1;
	        // Set<Integer> set = new HashSet<>();
	        // for(int i = 0; i < trust.length;i++){
	        //     if(!set.contains(trust[i][0])) set.add(trust[i][1]);
	        //     else set.remove(trust[i][0]);
	        // }
	        // if(set.size() == 1) {
	        //     Iterator<Integer> itr = set.iterator();
	        //     while(itr.hasNext()){
	        //         return itr.next();
	        //     }
	        // }
	        // return -1; 
	
	        int[] data = new int[N];
	        for(int[] da: trust){
	            data[da[1]-1] += 1;
	        }
	        boolean flag = false;
	
	        for(int i = 0;i < N;i++)
	            if(data[i] == N-1){
	                for(int j = 0;j < trust.length;j++){
	                    if(trust[j][0] == i+1) flag = true;
	                }
	                if(!flag) return i+1;
	
	            }
	        return -1;
	    }
	}

# 207. 课程表 #
思路：HashSet(不行)
拓扑。。。

	class Solution {
	    public boolean canFinish(int numCourses, int[][] prerequisites) {//numCourses个结点的有向图
	        int n=prerequisites.length;//n条边
	        ArrayList<Integer> [] adjacencyList=new ArrayList[numCourses];//邻接表
	        int [] inDegree=new int[numCourses];//入度数组，inDegree[i]的值表示节点i的入度
	        //先由边的集合构建邻接表
	        for(int i=0;i<numCourses;i++){
	            adjacencyList[i]=new ArrayList<>();//节点i的下标为i
	        }
	        for (int [] pre:prerequisites) {
	            adjacencyList[pre[1]].add(pre[0]);//pre=[0,1],1是边的起始点，0才是终点，是节点1指向节点0
	            inDegree[pre[0]]++;
	        }
	        //拓扑排序判断是不是DAG
	        return topologicalSort(adjacencyList,inDegree,numCourses);
	    }
	    private boolean topologicalSort(ArrayList<Integer> [] adjacencyList,int [] inDegree,int n){//邻接表和入度数组
	        int res=0;//拓扑排序能取出来的节点数目
	        Queue<Integer> queue=new LinkedList<Integer>();//存储入度为0的节点
	        for(int i=0;i<n;i++){
	            if(inDegree[i]==0) queue.offer(i);//节点i的入度为0，添加进队列
	        }
	         while (!queue.isEmpty()) {
	            int i = queue.poll();//取出节点i
	            res++;
	            for (int child_of_i : adjacencyList[i]) {//对节点i指向的每一个节点
	                inDegree[child_of_i]--;
	                if (inDegree[child_of_i] == 0) queue.offer(child_of_i);
	            }
	           
	        }
	        return res==n;
	    }
	}
