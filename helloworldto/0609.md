# 1046. 最后一块石头的重量 #
思路：首先排序，然后比较最大的两个，重新排序（一开始使用数组元素比较插入，使用自带的系统复制算法，然而arrays的复制算法会因为长度不同报错，只好重新排序）

	class Solution {
	    public int lastStoneWeight(int[] stones) {
	        int index = stones.length - 1;
	        for(int i = 0; i < stones.length - 1; i++){     
	            Arrays.sort(stones);                        
	            stones[index] -= stones[index-1];           
	            stones[index-1] = 0;
	        }
	        return stones[stones.length-1];
	
	
	    }
	}

# 973. 最接近原点的 K 个点 #
思路：首先定义一维数组，保存每个点到原点的平方距离，然后在一维数组中做排序，排K次，每次取数组中最小的一个存入结果中并将一维中该位置的值置为最大

	class Solution {
	    public int[][] kClosest(int[][] points, int K) {
	        int[] data = new int[points.length];
	        for(int i = 0; i < points.length;i++){
	            data[i] = points[i][0]*points[i][0] + points[i][1]*points[i][1];
	        }
	        int[][] res = new int[K][2];
	        for(int i = 0; i < K;i++){
	            int max = 0;
	            for(int j = 0; j < data.length;j++){
	                max = data[max] > data[j] ? j : max;
	            }
	            res[i][0] = points[max][0];
	            res[i][1] = points[max][1];
	            data[max] = Integer.MAX_VALUE; 
	        }
	        return res;
	
	    }
	}

