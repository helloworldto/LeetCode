# 28. 实现 strStr() #
思路:Sring 函数 indexOf

	class Solution {
	    public int strStr(String haystack, String needle) {
	        return haystack.indexOf(needle);
	    }
	}

# 2. 两数相加 #
思路：进位加法

	class Solution {
	    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
	        if(l1 == null && l2 == null) return l1;
	        if(l1 == null) return l2;
	        if(l2 == null) return l1;
	        ListNode node = new ListNode();
	        ListNode tmp = node;
	        int index = 0;
	        while(l1 != null && l2!= null){
	            tmp.next = new ListNode((l1.val+l2.val + index)%10);
	            index = (l1.val+l2.val + index)/10;
	            tmp =tmp.next;
	            l1 = l1.next;
	            l2 = l2.next;
	        }
	        while(l1 != null) {
	            tmp.next = new ListNode((l1.val + index)%10);
	            index = (l1.val + index)/10;
	            l1 = l1.next;
	            tmp =tmp.next;
	
	        }
	
	         while(l2 != null) {
	            tmp.next = new ListNode((l2.val + index)%10);
	            index = (l2.val + index)/10;
	            l2 = l2.next;
	            tmp =tmp.next;
	
	        }
	        if(index != 0) tmp.next = new ListNode(index);
	        return node.next;
	        
	    }
	}

# 149. 直线上最多的点数 #
思路：计算斜率


	class Solution {
	    public int maxPoints(int[][] points) {
	        int n = points.length;
	        if (n == 0) return 0;
	        if (n == 1) return 1;
	        int res = 0;
	        for (int i = 0; i < n - 1; i++) {
	            Map<String, Integer> slope = new HashMap<>();
	            int repeat = 0;
	            int tmp_max = 0;
	            for (int j = i + 1; j < n; j++) {
	                int dy = points[i][1] - points[j][1];
	                int dx = points[i][0] - points[j][0];
	                if (dy == 0 && dx == 0) {
	                    repeat++;
	                    continue;
	                }
	                int g = gcd(dy, dx);
	                if (g != 0) {
	                    dy /= g;
	                    dx /= g;
	                }
	                String tmp = String.valueOf(dy) + "/" + String.valueOf(dx);
	                slope.put(tmp, slope.getOrDefault(tmp, 0) + 1);
	                tmp_max = Math.max(tmp_max, slope.get(tmp));
	            }
	            res = Math.max(res, repeat + tmp_max + 1);
	        }
	        return res;
	    }
	
	    private int gcd(int dy, int dx) {
	        if (dx == 0) return dy;
	        else return gcd(dx, dy % dx);
	    }
	}

